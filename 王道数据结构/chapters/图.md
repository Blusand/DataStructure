# 图

## 图的基本概念

### 图的定义

图G由顶点集V和边集E组成，即为G = (V, E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若V = {v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>n</sub>}，则用|V|表示图G中顶点的个数，E = {(u, v) | u ∈ V, v∈ V}，用|E|表示图G中边的条数

图不可以是空图，即图不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空



#### 基本概念及术语

**有向图**：若E是有向边（也称**弧**）的有限集合时，则图G为有向图。弧是顶点的有序对，记为**<v, w>**，其中v，w是顶点，v称为弧尾，w称为弧头，<v, w>称为从v到w的弧，也称v邻接到w

如下面的有向图G<sub>1</sub>可以表示为：

G<sub>1</sub> = (V<sub>1</sub>, E<sub>1</sub>)，V<sub>1</sub> = {1, 2, 3}，E<sub>1</sub> = {<1, 2>, <2, 1>, <2, 3>}

<img src="pictures\图\01.png" style="zoom:50%;" />

**无向图**：若E是无向边（简称**边**）的有限集合时，则图G为无向图。边是顶点的无序对，记为**(v, w)**或**(w, v)**。可以说w和v互为邻接点。边(v, w)附着于w和v，或称边(v, w)和v，w相关联

如下面的无向图G<sub>2</sub>可以表示为：

G<sub>2</sub> = (V<sub>2</sub>, E<sub>2</sub>)，V<sub>2</sub> = {1, 2, 3, 4}，E<sub>2</sub> = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}

<img src="pictures\图\02.png" style="zoom:50%;" />

**简单图**：一个图G满足：①不存在重复边；②不存在顶点到自身的边

**多重图**：图G中某两个顶点之间的边数大于1条，又允许顶点通过一条边和自身相关联

**完全图（简单完全图）**：

- 对于无向图：|E|的取值范围为**0 ~ n(n - 1) / 2**，有n(n - 1) / 2条边的无向图称为完全图（任意两个顶点之间都存在边）
- 对于有向图：|E|的取值范围为**0 ~ n(n - 1)**，有n(n - 1) / 2条弧的有向图称为有向完全图（任意两个顶点之间都存在方向相反的两条弧）

**子图**：设有两个图G = (V, E)和G<sup>'</sup> = (V<sup>'</sup>, E<sup>'</sup>)，若V<sup>'</sup>是V的子集，且E<sup>'</sup>是E的子集，则称G<sup>'</sup>是G的子图

**生成子图**：若有满足V(G<sup>'</sup>) = V(G)的子图G<sup>'</sup>，则称其为G的生成子图

注意并非V和E的任何子集都能构成G的子图，因为这样的子集可能不是图

**连通**：在无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的

**连通图**：图G中任意两个顶点都是连通的，否则称为非连通图

**连通分量**：无向图中的极大连通子图称为连通分量

<img src="pictures\图\03.png" style="zoom: 67%;" />

假设一个图有n个顶点，如果边数小于n - 1，那么此图必是非连通图

如果图是非连通图，那么最多可以有多少条边？
$$
无向图：C_{n - 1}^2	\\ 有向图：2C_{n - 1}^2
$$
非连通情况下边最多的情况：由n - 1个顶点构成一个完全图，此时再任意加入一条边则变成连通图

有向图强连通情况下边最少的情况：至少需要n条边，构成一个环路

**强连通图**：在有向图中，如果有一对顶点v到w，从v到w和从w到v之间都有路径，则称这两个顶点是强连通的

**强连通图**：图中任何一对顶点都是强连通的

**强连通分量**：有向图的极大强连通子图称为有向图的强连通分量

<img src="pictures\图\04.png" style="zoom: 50%;" />

注意：在无向图中讨论连通性，在有向图中讨论强连通性

**生成树**：连通图的生成树是包含图中全部顶点的一个**极小连通子图**。若图中顶点数为**n**，则它的生成树含有**n - 1**条边。对于生成树而言，若砍去它的一条边，则会变成非连通图；若加上一条边，则会形成一个回路

**生成森林**：在非连通图中，连通分量的生成树构成了非连通图的生成森林

<img src="pictures\图\05.png" style="zoom: 50%;" />

区分极大连通子图和极小连通子图：

- **极大连通子图**：无向图的连通分量，极大即要求该连通子图包含其所有的边
- **极小连通子图**：既要保持图连通，又要使得边数最少的子图

**顶点的度**：

- 在无向图中，顶点v的度是指依附于顶点v的边的条数，记为**TD(v)**。对于具有n个顶点、e条b边的无向图，有

$$
\sum_{i = 1}^n TD(v_i) = 2e
$$

即无向图的全部顶点的度的和等于边数的2倍，因为每条边和两个顶点向关联

- 在有向图中，顶点v的度分为入度和出度，入度是以顶点v为重点的有向边的数目，记为**ID(v)**；而出度是以顶点v为起点的有向边的数目，记为**OD(v)**。顶点v的度等于其入度与出度之和，即**TD(v) = ID(v) + OD(v)**。对于具有n个顶点、e条b边的有向图，有

$$
\sum_{i = 1}^n ID(v_i) = \sum_{i = 1}^n OD(v_i) = e
$$

即有向图的全部顶点的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点

**边的权**：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值

**网**：边上带有权值的图称为带权图，也称网

**稠密图**：边数很少的图

**稀疏图**：边数很多的图

**路径**：顶点v<sub>p</sub>到顶点v<sub>q</sub>之间的一条路径是指顶点序列v<sub>p</sub>, v<sub>i<sub>1</sub></sub>, v<sub>i<sub>2</sub></sub>, ..., v<sub>i<sub>m</sub></sub>, v<sub>q</sub>，当然，关联的边也可以理解为路径的构成要素

**路径长度**：路径上边的数目

**回路**：第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有n个顶点，并且有大于n - 1条边，则此图一定有环

**简单路径**：在路径序列中，顶点不重复出现的路径

**简单回路**：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路

**距离**：从顶点u出发到顶点v的**最短路径**若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷（∞）

**有向树**：一个顶点的入度为0，其余顶点的入度为1的有向图



## 图的存储及基本操作

### 邻接矩阵法

定义：指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间关系的二维数组称为临界矩阵

结点数为n的图G = (V, E)的邻接矩阵A是n × n的。将G的顶点编号为v<sub>1</sub>, v<sub>2</sub>,..., v<sub>n</sub>。若(v<sub>i</sub>, v<sub>j</sub>) ∈ E，则A\[i][j] = 1，否则A\[i][j] = 0：

<img src="pictures\图\06.png" style="zoom: 50%;" />

对于带权图而言，若顶点v<sub>i</sub>和v<sub>j</sub>之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点v<sub>i</sub>和v<sub>j</sub>不相连，则用∞来代表这两个顶点之间不存在边：

<img src="pictures\图\07.png" style="zoom: 50%;" />



```c++
// 图的邻接矩阵存储结构定义
#define MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;

typedef struct {
    VertexType Vex[MaxVertexNum];           // 顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];  // 邻接矩阵，边表
    int vexnum, arcnum;         // 图的当前顶点数和弧数
}MGraph;
```

<img src="pictures\图\08.png" style="zoom: 80%;" />

注意：

- 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储
- 邻接矩阵表示法的**空间复杂度为O(n)**，其中n为图的顶点数|V|

图的邻接矩阵存储表示法具有以下特点：

- 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储领接矩阵时只需存储上（或下）三角矩阵的元素
- 对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是顶点i的度TD(v<sub>i</sub>)
- 对于有向图，邻接矩阵的第i行非零元素（或非∞元素）的个数正好是顶点i的出度OD(v<sub>i</sub>)；第i列非零元素（或非∞元素）的个数正好是顶点i的入度ID(v<sub>i</sub>)
- 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测
- 稠密图适合使用邻接矩阵的存储表示
- 设图G的邻接矩阵为A，A<sup>n</sup>的元素A<sup>n</sup>\[i][j]等于由顶点i到顶点j的长度为n的路径的数目



### 邻接表法

当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了空间的浪费

邻接表法指对图G中的每个顶点v<sub>i</sub>建立一个单链表，第i个单链表中的结点表示依附于顶点v<sub>i</sub>的边（对于有向图则是以顶点v<sub>i</sub>为尾的弧），这个单链表就称为顶点v<sub>i</sub>的**边表**（对于有向图则称为**出边表**）。边表的头指针和顶点的数据信息采用顺序存储（称为**顶点表**），所以在邻接表中存在两种结点：**顶点表结点**和**边表结点**，如下图所示：

<img src="pictures\图\09.png" style="zoom: 67%;" />

- **顶点表结点**：由顶点域和指向第一条邻接边的指针构成
- **边表结点**：由邻接点域和指向下一条邻接边的指针域构成

```c++
// 图的邻接表存储结构定义
#define MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;

typedef struct ArcNode{     // 边表结点
    int adjvex;             // 该弧所指向的顶点的位置
    struct ArcNode* next;   // 指向下一条弧的指针
    // 网的边权值
}ArcNode;

typedef struct VNode {          //顶点表结点
    VertexType data;            // 顶点信息
    ArcNode* first;             // 指向第一条依附该顶点的弧的指针
}VNode, AdjList[MaxVertexNum];

typedef struct {
    AdjList vertices;       // 邻接表
    int vexnum, arcnum;     // 图的顶点数和弧数
}ALGraph;                   // ALGraph是以邻接表存储的图类型表存储的图类型
```

如下图：

<img src="pictures\图\10.png" style="zoom: 80%;" />



### 十字链表

十字链表是**有向图**的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。这些结点的结构如下：

<img src="pictures\图\11.png" style="zoom: 80%;" />

弧结点有5个域：

- 尾域（tailvex）：指示弧尾在图中的位置
- 头域（headvex）：指示弧头在图中的位置
- 链域hlink：指向弧头相同的下一条弧
- 链域tlink：指向弧尾相同的下一条弧
- info域：指向该弧的相关信息

这样，弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上

顶点结点中有3个域：

- data域：存放顶点相关的数据信息，如顶点名称
- firstin域：指向以该顶点为弧头的第一个弧结点
- firstout域：指向以该顶点为弧尾的第一个弧结点

如下图一个有向图的十字链表表示法：

<img src="pictures\图\12.png" style="zoom: 80%;" />

图的十字链表表示是不唯一的，但一个十字链表表示确定一个图



### 邻接多重表

邻接多重表是**无向图**的另一种链式存储结构

与十字链表类似，在邻接多重表中，每条边同一个结点表示，其结构如下图：

<img src="pictures\图\13.png" style="zoom: 80%;" />

边有5个域：

- mark：标志域，可用以标记该条边是否被搜索过
- ivex：该边依附的顶点在图中的位置
- jvex：该边依附的顶点在图中的位置
- ilink：指向下一条依附于顶点ivex的边
- jlink：指向下一条依附于顶点jvex的边
- info：指向和边相关的各种信息的指针域

每个顶点也用一个结点表示：

<img src="pictures\图\14.png" style="zoom: 67%;" />

顶点有2个域：

- data：存储该顶点的相关信息
- firstedge：指示第一条依附于该顶点的边

在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。对于无向图而言，其邻接多重表和邻接表的区别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点

下图为无向图的邻接多重表表示：

<img src="pictures\图\15.png" style="zoom: 80%;" />



## 图的遍历

定义：图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。为了避免痛殴一个顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设计一个辅助数组**vistied[]**来标记顶点是否被访问过。图的遍历算法有两种：**广度优先搜索**和**深度优先搜索**



### 广度优先搜索（BFS）

类似于二叉树的层次遍历算法。

基本思想：首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w<sub>1</sub>, w<sub>2</sub>,..., w<sub>i</sub>，然后依次访问w<sub>1</sub>, w<sub>2</sub>,..., w<sub>i</sub>的所有未被访问过的邻接顶点；再从这些顶点出发，访问它们所有未被访问过的邻接顶点，直到图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问过的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问过为止。

广度优先搜索是一种分层的查找过程，每向前走一步都可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。

```c++
bool visited[MaxVertexNum];     // 访问标记数组
SqQueue Q;      // 辅助队列

void BFS(Graph G, int vex) {
    visit(vex);       // 访问初始顶点v
    visited[vex] = true;    // 对vex做已访问标记
    EnQueue(Q, vex);
    while (!QueueIsEmpty(Q)) {
        DeQueue(Q, vex);
        for (w = FirstNeighbor(G, vex); w >= 0; 
            w = NextNeighbor(G, vex, w)) {  // 检测vex所有邻接点
            visit(w);
            visited[w] = true;
            EnQueue(Q, w);
        }
    }
}

void BFSTraverse(Graph G) {     // 对图G进行广度优先遍历
    for (int i = 0; i < G.vexnum; ++i)
        visited[i] = false;
    InitQueue(Q);
    for (int i = 0; i < G.vexnum; ++i)  // 从0号顶点开始遍历
        if (!visited[i])    // 对每个连通分量调用一次BFS
            BFS(G, i);
}
```

辅助数组visited[]标志顶点是否被访问过，其初始状态为false。在图的遍历过程中，一旦某个顶点v<sub>i</sub>被访问，阶立即置visited[i]为true，防止它被多次访问

下面通过实例演示广度优先搜索的过程，给定图G如下图所示：

<img src="pictures\图\16.png" style="zoom: 80%;" />

假设从a结点开始访问，α先入队。此时队列非空，取出队头元素a，由于b，c与a邻接且未被访问过，于是依次访问b，c，并将b，c依次入队。队列非空，取出队头元素b，依次访问与b邻接且未被访问的顶点d，e，并将d，e入队（注意：a与b也邻接，但α已置访问标记，故不再重复访问）。此时队列非空，取出队头元素c，访问与c邻接且未被访问的顶点f，g并将f，g入队。此时，取出队头元素d，但与d邻接且未被访问的顶点为空，故不进行任何操作。继续取出队头元素e，将h入队列……最终取出队头元素h后，队列为空，从而循环自动跳出。遍历结果为a b c d e f g h

#### BFS算法的性能分析

无论是邻接表还是邻接矩阵的存储方法，BFS算法都需要借助一个辅助队列Q，n个顶点均需入队一次，在最坏情况下，空间复杂度为O(n)

- **邻接表**存储方式：每个顶点均需搜索一次（或入队一次），故时间复杂度为O(|V|)，在搜索任一顶点的邻接点时，每条边至少访问依次，故时间复杂度为O(|E|)，算法总的**时间复杂度为O(|V| + |E|)**
- **邻接矩阵**存储方法：查找每个顶点的邻接点所需的时间都为O(|V|)，故算法总的**时间复杂度为O(|V|<sup>2</sup>)**



#### BFS算法求解单源最短路径问题

若图G = (V, E)为非带权图，定义从顶点u到顶点v的**最短路径d(u, v)**为从u到v的任何路径中最少的边；若从u到v没有通路，则d(u, v) = ∞

使用BFS，我们可以求解一个满足上述定义的**非带权图**的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的

```c++
void BFS_MIN_Distance(Graph G, int u) {
    // d[i]表示从u到i结点的最短路径
    for (int i = 0; i < G.vexnum; ++i)
        d[i] = ∞;        // 初始化路径长度
    visited[u] = true;
    d[u] = 0;    // 顶点u到自身的距离为0
    EnQueue(Q.u);
    while (!QueueIsEmpty(Q)) {
        DeQueue(Q, u);
        for (w = FirstNeighbor(G, u); w >= 0;
            w = NextNeighbor(G, u, w)) {
            if (!visited[w]) {      // w为u的尚未访问的邻接顶点
                visited[w] = true;
                d[w] = d[u] + 1;        // 路径长度加1
                EnQueue(Q, w);
            }
        }
    }
}
```



#### 广度优先生成树

在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树，如下图所示：

<img src="pictures\图\17.png" style="zoom: 80%;" />

注意：一给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的；但由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的



### 深度优先搜索（DFS）

类似于树的先序遍历，这种搜索算法所遵循的搜索策略是尽可能“深”地搜索一个图

基本思想：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w<sub>1</sub>，再访问与w<sub>1</sub>邻接且未被访问的任一顶点w<sub>2</sub>...重读上述过程。当不能再继续向下访问时，依次退回到最近被访问过的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止

```c++
bool visited[MaxVertexNum];

void DFS(Graph G, int vex) {
    visit(vex);
    visited[vex] = true;
    for (w = FirstNeighbor(G, vex); w >= 0;
        w = NextNeighbor(G, vex, w)) {
        if (!visited[w])
            DFS(G, w);
    }
}

void DFSTraverse(Graph G) {
    for (int vex = 0; vex < G.vexnum; ++vex)
        visited[vex] = false;
    for (int vex = 0; vex < G.vexnum; ++vex)
        if (!visited[vex])
            DFS(G, vex);
}
```

下面通过实例演示深度优先搜索的过程，给定图G如下图所示：

<img src="pictures\图\16.png" style="zoom: 80%;" />

深度优先搜索的过程：首先访问a，并置a访问标记；然后访问与a邻接且未被访问的顶点b，置b访问标记；然后访问与b邻接且未被访问的顶点d，置d访问标记。此时d已没有未被访问过的邻接点，故返回上一个访问过的顶点b，访问与其邻接且未被访问的顶点e，置e访问标记……以此类推，直至图中所有的顶点都被访问一次。遍历结果为a b d e h c f g



#### 深度优先算法的性能分析

DFS是一个递归算法，需要借助一个递归工作栈，故其**空间复杂度为O(|V|)**

遍历图的过程实质上是对每个顶点查找其邻接点的过程，其消耗的时间取决于所用的存储结构：

- **邻接表**存储方式：查找所有顶点的邻接点所需的时间为O(|E|)，访问顶点所需的时间为O(|V|)，此时，总的**时间复杂度为O(|V| + |E|)**
- **邻接矩阵**存储方式：查找每个顶点的邻接点所需的时间为O(|V|)，访问顶点所需的时间为O(|V|)，故总的**时间复杂度为O(|V<sup>2</sup>|)**



#### 深度优先的生成树和生成森林

深度优先搜索也会产生一棵深度优先生成树，如下图：

<img src="pictures\图\17.png" style="zoom: 80%;" />

对**连通图**调用DFS才能产生深度优先生成树，否则产生的是深度优先生成森林。并且，基于邻接表存储的深度优先生成树是不唯一的



### 图的遍历与图的连通性

图的遍历算法可以用来判断图的连通性

- 无向图：若无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一顶点出发，一次遍历只能访问该顶点所在的连通分量的所有顶点
- 有向图：若从初始顶点到图中的每个顶点都有路径，则能够访问到图中所有顶点；否则不能访问到所有顶点

因此在BFSTraverse()和DFSTraverse()中添加了第二个for循环，在选取初始点，继续进行遍历，防止一次无法遍历图的所有顶点

- 无向图：上述两个函数调用BFS(G, i)或DFS(G, i)的次数等于该图的**连通分量数**
- 有向图：因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用BFS(G, i)或DFS(G, i)无法访问到该连通分量的所有顶点，如下图所示：

<img src="pictures\图\18.png" style="zoom: 50%;" />



## 图的应用

### 最小生成树

一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路

对于一个带权连通无向图G = (V, E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中边的权值之和最小的那棵生成树，则T称为G的**最小生成树（MST）**

最小生成树具有如下性质：

- 最小生成树**不唯一**，当图G中的各边权值互不相等时，G的最小生成树是唯一的；若无向连通图G的边数比顶点数少1，即G本身是一棵树时，则G的最小生成树就是它本身
- 最小生成树的边的权值之和总是唯一的，而且是最小的
- 最小生成树的边数为顶点数减1

大多数最小生成树的算法都利用了最小生成树的下列性质：假设G = (V, E)是一个带权连通无向图，U是顶点集V的一个非空子集。若(u, v)是一条具有最小权值的边，其中u ∈ U， v ∈ V - U，则必存在一棵包含边(u, v)的最小生成树

基于该性质的最小生成树算法有**Prim算法**和**Kruskal算法**，它们都基于**贪心算法**的策略

下面是通用的最小生成树算法：

```c++
GENERIC_MST(G) {
    T = null;
    while T未形成一棵生成树；
        do 找到一条最小代价边(u, v)并且加入T后不会产生回路;
    		T = T ∪ (u, v);
}
```

通用算法每加入一条边以逐渐形成一棵生成树



#### Prim算法（加点法）

Prim（普里姆）算法的执行非常类似于寻找图的最短路径Dijkstra算法

Prim算法构造的最小生成树的过程如下图所示：

<img src="pictures\图\19.png" style="zoom: 80%;" />

初始时从图中任取一顶点（如顶点1）加入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合**距离最近**的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增加1,。以此类推，直至图中所有的顶点都并入T，得到的T就是最小生成树。此时T中必然有**n - 1**条边

Prim算法的步骤如下：

- 假设G = {V, E}是连通图，其最小生成树T = (U, E<sub>T</sub>)，E<sub>T</sub>是最小生成树中边的集合
- 初始化：向空树T = (U, E<sub>T</sub>)中添加图G = (V, E)的任一顶点u<sub>0</sub>，E<sub>T</sub> = ∅
- 循环（重复下列操作直至U = V）：从图G中选择满足{(u, v) | u ∈ U, v ∈ V - U}且具有最小权值的边(u, v)，加入树T，置U = U ∪ {v}，E<sub>T</sub> = E<sub>T</sub> ∪ {(u, v)}

Prim算法的简单实现如下：

```c++
void Prim(G, T) {
    T = ∅;			// 初始化空树
    U = {w};		// 添加任一顶点w
    while ((V - U) != ∅) {	// 若树中不含全部顶点
        设(u, v)是使u ∈ U, v ∈ V - U，且权值最小的边;
        T = T ∪ {(u, v)};		// 边归入树
        U = U ∪ {v};			// 顶点归入树
    }
}
```

Prim算法的**时间复杂度为O(|V<sup>2</sup>|)**，不依赖于|E|，因此它适用于求解**边稠密**的最小生成树



#### Kruskal算法（加边法）

Kruskal（克鲁斯卡尔）算法是一种按**权值的递增次序**选择合适的边来构造最小生成树的方法

Kruskal算法构造最小生成树的过程如下图所示：

<img src="pictures\图\20.png"  />

初始时为只有n个顶点而无边的非连通图T = {V, {}}，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若改边依附的顶点落在T中不同的连通分量上，则将此边加入T，否则舍弃此边而选择下一条权值最小的边。以此类推，直至T所有顶点都在一个连通分量上

Kruskal算法的步骤如下：

- 假设G = {V, E}是连通图，其最小生成树T = (U, E<sub>T</sub>)
- 初始化：U = V， E<sub>T</sub> = ∅。即每个顶点构成一棵独立的树，T此时是一个仅含|V|个顶点的森林
- 循环（重复下列操作直至T是一棵树）：按G的边的权值递增顺序依次从E - E<sub>T</sub>中选择一条边，若这条边加入T后**不构成回路**，则将其加入E<sub>T</sub>，否则舍弃，直至E<sub>T</sub>中含有n - 1条边

Kruskal算法的简单实现如下：

```c++
void Kruskal(V, T) {
    T = V;		// 初始化树T，仅含顶点
    numS = n;	// 连通分量数
    while (numS > 1) {		// 若连通分量数大于1
        从E中取出权值最小的边(u, v);
        if (v和u属于T中不同的连通分量) {
            T = T ∪ {(v, u)};		// 将此边加入生成树中
            numS--;			// 连通分量数减1
        }
    }
}
```

根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树

通常在Kruskal算法中，采用**堆**来存放边的集合，因此每次选择权值最小的边只需O(log<sub>2</sub>|E|)的时间。此外，由于生成树T中的所有边可视为一个等价类，因此每次添加新的边的过程类似于求解等价类的过程，由此可以采用**并查集**的数据结构来描述T，从而构造T的**时间复杂度为O(|E|log<sub>2</sub>|E|)**。因此，Kruskal算法适用于**边稀疏而顶点较多**的图



### 最短路径

当图是带权图时，把从一个顶点v<sub>0</sub>到图中其余任一个顶点v<sub>i</sub>的一条路径（可能不止一条）所经过边上的权值之和，定义为该路径的**带权路径长度**，把带权路径长度最短的那条路径称为**最短路径**

求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图G的最短路径问题一般可以分为两类：

- 单源最短路径，即求图中某一顶点到其他各顶点的最短路径，使用**Dijkstra（迪杰斯特拉）算法**
- 求每对顶点键的最短路径，使用**Floyd（弗洛伊德）算法**



#### Dijkstra算法求单源最短路径问题

Dijkstra算法设置一个集合S记录已求得的最短路径的顶点，初始时把源点v<sub>0</sub>放入S，集合S每并入一个新顶点v<sub>i</sub>，都要**修改源点v<sub>0</sub>到集合V - S中顶点当前的最短路径长度值**

在构造的过程中还设置了两个辅助数组：

- **dist[]**：记录从源点v<sub>0</sub>到其他各顶点当前得最短路径长度，它的初始态为：若从v<sub>0</sub>到v<sub>i</sub>有弧，则dist[i]为弧上的权值；否则置dist[i]为∞
- **path[]**：path[i]表示从源点到顶点i之间的最短路径的前驱结点。在算法结束时，可以根据其值追溯得到源点v<sub>0</sub>到顶点v<sub>i</sub>的最短路径

假设从顶点0出发，即v<sub>0</sub> = 0，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs\[i][j]表示有向边<i, j>的权值，若不存在有向边<i, j>，则arcs\[i][j]为∞

Dijkstra算法的步骤如下：

- ①初始化：集合S初始为{0}，dist[]的初始值dist[i] = arcs\[0][i]，i = 1，2，...， n - 1
- ②从顶点集合V - S中选出v<sub>j</sub>，满足dist[j] = Min{dist[i] | v<sub>i</sub> ∈ V - S}（找出dist[]中最小的值），v<sub>j</sub>就是当前求得的一条从v<sub>0</sub>出发的最短路径的终点，令S = S ∪ {j}
- ③修改从v<sub>0</sub>出发到集合V - S上任一顶点v<sub>k</sub>可达的最短路径长度：若dist[j] + arcs\[j][k] < dist[k]，则更新dist[k] = dist[j] + arcs\[j][k]
- ④重复② ~ ③操作共n - 1次，直到所有的顶点都包含在S中

步骤③：每当一个顶点加入S后，可能需要修改源点v<sub>0</sub>到集合V - S中可达顶点当前的最短路径，如下面的例子：源点为v<sub>0</sub>，初始时S = {v<sub>0</sub>}，dist[1] = 3，dist[2] = 7，当将v<sub>1</sub>并入集合S后，dist[2]需要更新为4（dist[2] = dist[1] + arcs\[1][2]）

<img src="pictures\图\21.png"  />



下面是Dijkstra算法执行的过程（求从顶点1出发至其余顶点的最短路径的过程）：

<img src="pictures\图\22.png" style="zoom: 50%;" />

初始化：集合S初始为{v<sub>1</sub>}，v<sub>1</sub>可达v<sub>2</sub>和v<sub>5</sub>，v<sub>1</sub>不可达v<sub>3</sub>和v<sub>4</sub>；因此dist[]数组各元素的初值依次设置为dist[2] = 10，dist[3] = ∞，dist[4] = ∞，dist[5] = 5

- 第一轮：选出最小值dist[5]，将顶点v<sub>5</sub>并入集合S，即此时已找到v<sub>1</sub>到v<sub>5</sub>的最短路径。当v<sub>5</sub>加入S后，从v<sub>1</sub>到集合V - S中可达顶点的最短路径长度可能会产生变化。因此需要更新dist[]数组, v<sub>5</sub>可达v<sub>2</sub>，因v<sub>1</sub>→v<sub>5</sub>→v<sub>2</sub>的距离8比dist[2] = 10小，更新dist[2] = 8；v<sub>5</sub>可达v<sub>3</sub>，v<sub>1</sub>→v<sub>5</sub>一v<sub>3</sub>的距离14，更新dist[3] = 14；v<sub>5</sub>可达v<sub>4</sub>, v<sub>1</sub>→v<sub>5</sub>→v<sub>4</sub>的距离7，更新dist[4] = 7
- 第二轮：选出最小值dist[4]，将顶点v<sub>4</sub>并入集合S。继续更新dist[]数组。v<sub>4</sub>不可达v<sub>2</sub>，dist[2]不变；v<sub>4</sub>可达v<sub>3</sub>，v<sub>1</sub>→v<sub>5</sub>→v<sub>4</sub>→v<sub>3</sub>的距离13比dist[3]小，故更新dist[3] = 13
- 第三轮：选出最小值dist[2]，将顶点v<sub>2</sub>并入集合S。继续更新dist[]数组。v<sub>2</sub>可达v<sub>3</sub>，v<sub>1</sub>→v<sub>5</sub>→v<sub>2</sub>→v<sub>3</sub>的距离9比dist[3]小，更新dist[3] = 9
- 第四轮：选出唯一最小值dist[3]，将顶点v<sub>3</sub>并入集合S，此时全部顶点都已包含在S中

显然Dijkstra算法也是基于**贪心策略**的

使用**邻接矩阵**表示时，**时间复杂度为O(|V<sup>2</sup>|)**；使用带权的**邻接表**表示时，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，**时间复杂度仍为O(|V<sup>2</sup>|)**

注意，边上带有**负权值**时，Dijkstra算法并不适用，如下图：

<img src="pictures\图\23.png" style="zoom: 67%;" />

集合S初始为{v<sub>0</sub>}，dist[1] = 7，dist[2] = 5，因此把结点2并入集合S中；这时集合S = {v<sub>0</sub>, v<sub>2</sub>}，现在只剩下顶点v<sub>1</sub>了，把v<sub>1</sub>并入集合S中，算法结束，得出v<sub>0</sub>→v<sub>1</sub>的最短距离为7，v<sub>0</sub>→v<sub>2</sub>的最短距离为5，但实际上v<sub>0</sub>→v<sub>2</sub>的最短距离应该为2。原因是因为已求得最短路径的顶点集，**归入S内的结点的最短路径不再变更**，当顶点v<sub>1</sub>并入集合S后，最短距离7已经不能再更改了，但实际上应该是2才对



#### Floyd算法求各顶点之间最短路径问题

Floyd算法的基本思想：递推产生一个n阶方阵序列A<sup>(-1)</sup>, A<sup>(0)</sup>, ..., A<sup>(k)</sup>, ..., A<sup>(n - 1)</sup>，其中A<sup>(k)</sup>\[i][j]表示从顶点v<sub>i</sub>到顶点v<sub>j</sub>的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点v<sub>i</sub>和v<sub>j</sub>，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k（k = 0, 1, ..., n  - 1）作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。



算法描述如下：

定义一个n阶方阵序列A<sup>(-1)</sup>, A<sup>(0)</sup>, ..., A<sup>(k)</sup>, ..., A<sup>(n - 1)</sup>，其中A<sup>(-1)</sup>\[i][j] = arcs\[i][j]，A<sup>(k)</sup>\[i][j] = Min{A<sup>(k - 1)</sup>\[i][j], A<sup>(k - 1)</sup>\[i][k] + A<sup>(k - 1)</sup>\[k][j], k = 0, 1, ..., n - 1}。式中，A<sup>(0)</sup>\[i][j]是从顶点v<sub>i</sub>到v<sub>j</sub>、中间顶点是v<sub>0</sub>的最短路径的长度，A<sup>(k)</sup>\[i][j]是从顶点v<sub>i</sub>到v<sub>j</sub>、中间顶点的序号不大于k的最路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从v<sub>i</sub>到v<sub>j</sub>的最短路径上就多考虑了一个顶点；经过n次迭代后，所得到的A<sup>(n - 1)</sup>\[i][j]就是v<sub>i</sub>到v<sub>j</sub>的最短路径长度，即方阵A<sup>(n - 1)</sup>中保存了任意一对顶点之间的最短路径长度



如下图的一个带权有向图G和应用Floyd算法求所有顶点之间的最短路径长度的过程：

<img src="pictures\图\24.png"  />

算法执行过程如下：

- 初始化：方阵A<sup>(-1)</sup>\[i][j] = arcs\[i][j]
- 第一轮：将v<sub>0</sub>作为中间顶点，对于所有顶点对{i, j}，如果有A<sup>-1</sup>\[i][j] > A<sup>-1</sup>\[i][0] + A<sup>-1</sup>\[0][j]，则将A<sup>-1</sup>\[i][j]更新为A<sup>-1</sup>\[i][0] + A<sup>(-1)</sup>\[0][j]。有A<sup>-1</sup>\[2][1] > A<sup>-1</sup>\[2][0] + A<sup>-1</sup>\[0][1] = 11，更新A<sup>-1</sup>\[2][1] = 11，更新后的方阵标记为A<sup>0</sup>
- 第二轮：将v<sub>1</sub>作为中间顶点，继续检测全部顶点对{i, j}。有A<sup>0</sup>\[0][2] > A<sup>0</sup>\[0][1] + A<sup>0</sup>\[1][2] = 10，更新A<sup>0</sup>\[0][2] = 10，更新后的方阵标记为A<sup>1</sup>
- 第三轮：将v<sub>2</sub>作为中间顶点，继续检测全部顶点对{i, j}。有A<sup>1</sup>\[1][0] > A<sup>1</sup>\[1][2] + A<sup>1</sup>\[2][0] = 9，更新A<sup>(1)</sup>\[1][0] = 9，更新后的方阵标记为A<sup>2</sup>。此时A<sup>2</sup>中保存的就是任意顶点对的最短路径长度

如下图算法执行过程中矩阵的变化：

<img src="pictures\图\25.png"  />

还可以设置一个path矩阵（path\[n][n]），用来记录两个顶点之间的中转点，初始时所有顶点都没有中转点，因此path矩阵中的值全为-1，如下图所示：

<img src="pictures\图\31.png" style="zoom:67%;" />

在算法执行的过程中，若A<sup>(k - 1)</sup>\[i][j] > A<sup>(k - 1)</sup>\[i][k] + A<sup>(k - 1)</sup>\[j][k]，则在更新矩阵A的同时A<sup>(k)</sup>\[i][j] = A<sup>(k - 1)</sup>\[i][k] + A<sup>(k - 1)</sup>\[j][k]，矩阵path也进行更新，即：path<sup>(k)</sup>\[i][j] = k（意思是从i到j的中转点为k），否则A<sup>(k)</sup>和path<sup>(k)</sup>保持原值



路径寻找方法，如下面的图：

<img src="pictures\图\33.png" style="zoom:67%;" />

<img src="pictures\图\32.png" style="zoom:67%;" />

这里以寻找顶点v<sub>0</sub>到顶点v<sub>4</sub>的最短路径为例，可以看出，path\[0][4]中的值为3，即v<sub>0</sub>→v<sub>4</sub>中间有一个中转点v<sub>3</sub>，即v<sub>0</sub>→v<sub>3</sub>→v<sub>4</sub>，这时，path\[3][4] == -1即v<sub>3</sub>与v<sub>4</sub>之间已经没有中转点；而path\[0][3] == 2，即v<sub>0</sub>与v<sub>3</sub>之间还有一个中转点v<sub>2</sub>，因此路径变为v<sub>0</sub>→v<sub>2</sub>→v<sub>3</sub>→v<sub>4</sub>，这时path\[0][2] == -1；path\[2][3] == 1，因此路径变为v<sub>0</sub>→v<sub>2</sub>→v<sub>1</sub>→v<sub>3</sub>→v<sub>4</sub>，这就是顶点v<sub>0</sub>到顶点v<sub>4</sub>的最短路径

```c++
// 核心代码
// ...准备工作，根据图的信息初始化矩阵A和path
for (int k = 0; k < n; ++k) {	// 考虑以Vk为中转点
 	for (int i = 0; i <n; ++i) {	// 遍历整个矩阵，i为行号，j为列号
        for (int j = 0; j < n; ++j) {
            if (A[i][j] > A[i][k] + A[k][j]) {		// 以Vk为中转点的路径更短
                A[i][j] = A[i][k] + A[k][j];	// 更新最短路径长度
                path[i][j] = k;		// 中转点
            }
        }
    }   
}
```



总结：

|                |                BFS算法                 |      Dijkstra算法      |         Floyd算法          |
| :------------: | :------------------------------------: | :--------------------: | :------------------------: |
|     无权图     |                   √                    |           √            |             √              |
|     带权图     |                   ×                    |           √            |             √              |
|  带负权值的图  |                   ×                    |           ×            |             √              |
| 带负权回路的图 |                   ×                    |           ×            |             ×              |
|   时间复杂度   | O(\|V\|<sup>2</sup>)或O(\|V\| + \|E\|) |  O(\|V\|<sup>2</sup>)  |    O(\|V\|<sup>3</sup>)    |
|    通常用于    |         求无权图的单源最短路径         | 求带权图的单源最短路径 | 求带权图各顶点间的最短路径 |



Floyd算法的**时间复杂度为O(|V|<sup>3</sup>)**

Floyd算法**允许**图中**带有负权值的边**，但**不允许**有**包含负权值的边组成的回路**。它同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图

也可以用单源最短路径算法（Dijkstra算法）来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源点，并且在所有边权值均非负值时，运行一次Dijkstra算法，其时间复杂度为O(|V|<sup>2</sup>)*|V| = O(|V|<sup>3</sup>)



### 有向无环图描述表达式

有向无环图：若一个有向图中不存在环，则称为有向无环图，简称**DAG图**

有向无环图是描述含有公共子表达式的有效工具，例如表达式：
((a + b) * (b * (c + d)) + (c + d) * e) * ((c + d) * e)

可用一个二叉树来表示，其中，如表达式(c + d)和(c + d) * e在原表达式中重复多次。若利用有向无环图，则可以实现对相同子式的共享，从而节省存储空间，如下图：

<img src="pictures\图\26.png"  />

转换的步骤：

- 把各个操作数不重复地排成一排

- 标出各个运算符的生效顺序

  <img src="pictures\图\27.png" style="zoom:67%;" />

- 按顺序加入运算符，注意分层

  <img src="pictures\图\28.png" style="zoom: 50%;" />

- 自底向上逐层检查同层的运算符是否可以合并（同层合并）

  <img src="pictures\图\29.png" style="zoom: 67%;" />



### 拓扑排序

AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边<V<sub>i</sub>, V<sub>j</sub>>表示活动V<sub>i</sub>必须先于活动V<sub>j</sub>进行的这样一种关系，则将这种有向图称为**顶点表示活动的网络**，记为**AOV网**。在AOV网中，活动V<sub>i</sub>是活动V<sub>j</sub>的**直接前驱**，活动V<sub>j</sub>是活动V<sub>i</sub>的**直接后继**，这种前驱和后继关系具有传递性，且任何活动V<sub>i</sub>不能以它自己作为自己的前驱或后继

**拓扑排序**：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，成为该图的一个拓扑排序：

- 每个顶点出现且只出现一次
- 若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。每个AOV网都有一个或多个拓扑排序序列



对一个AOV进行拓扑排序的算法：

- ①从AOV网中选择一个没有前驱的顶点并输出
- ②从网中删除该顶点和所有以它为起点的有向边
- ③重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环

如下图一个有向无环图的拓扑排序过程：

<img src="pictures\图\30.png" style="zoom: 50%;" />

<img src="pictures\图\34.png" style="zoom: 80%;" />

indegree[]数组用于存放当前顶点的入度，而print[]数组用于记录拓扑排序，顶点为1的点放在数组下标为0处，其他顶点依次类推。保存度为0的顶点也可以用队列而不一定是栈

```c++
// 拓扑排序
SqStack S;
bool TopologicalSort(ALGraph G) {
    InitStack(S);   // 初始化栈，存入入度为0的顶点
    int i;
    for (i = 0; i < G.vexnum; ++i)
        if (indegree[i] == 0)
            Push(S, i);     // 将所有入度为0的顶点进栈
    int count0 = 0;          // 计数，记录当前已经输出的顶点数
    while (!StackIsEmpty(S)) {      // 栈不空，则存在入度为0的顶点
        Pop(S, i);
        print[count++] = i;     // 输出顶点i
        for (ArcNode* p = G.vertices[i].first; p; p = p->next) {
            // 将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S
            int v = p->adjvex;
            if (!(--indegree[v]))
                Push(S, v);     // 入度为0，则入栈
        }
    }
    if (count < G.vexnum)
        return false;       // 排序失败，有向图中有回路
    else
        return true;        // 拓扑排序成功
}
```

由于输出每个顶点的同时还要删除以它为起点的边，故拓扑排序的**时间复杂度为O(|V| + |E|)**



对于一个AOV网，如果采用下列步骤进行排序，则称之为**逆拓扑排序**：

- ①从AOV网中选择一个没有后继（出度为0）的顶点并输出
- ②从网中删除该顶点和所有以它为终点的有向边
- ③重复①和②直到当前的AOV网为空

```c#
// 逆拓扑排序（DFS算法）
bool visited[MaxVertexNum];

void DFS(Graph G, int vex) {
    visited[vex] = true;
    for (w = FirstNeighbor(G, vex); w >= 0;
        w = NextNeighbor(G, vex, w)) {
        if (!visited[w])
            DFS(G, w);
    }
}

// DFS实现拓扑排序：在顶点退栈前输出
void DFSTraverse(Graph G) {	// 对图进行深度优先遍历
    for (int vex = 0; vex < G.vexnum; ++vex)
        visited[vex] = false;
    for (int vex = 0; vex < G.vexnum; ++vex)
        if (!visited[vex])
            DFS(G, vex);
    print(vex);		// 输出顶点
}
```

使用逆拓扑排序时，如果图存在回路，该怎么处理？

把visited数组改为int类型，-1表示该节点未被访问，0表示已被访问，1表示已被访问且已被输出，当DFS访问到结点v时，设visited[v] = 0，而当退栈print(v)时，设visited[v] = 1，表示该结点已被输出。最后，if语句判断w对应的visited[w]是否为0，是0的话就表明图中存在回路，DFS结束并反馈



用拓扑排序算法处理AOV网时，应该注意一下问题：

- 入度为0的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续
- 若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排在一个线性有序的序列中，每个顶点都有唯一的前驱后继关系，则拓扑排序的结果是唯一的
- 由于AOV网中各顶点的地位平等，每个顶点编号都是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接矩阵，这种邻接矩阵可以是三角形矩阵；但对于一般的图来说，若其邻接矩阵时三角矩阵，则存在拓扑排序；反之则不一定成立



### 关键路径

在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成该活动所需的时间），称之为用边表示活动的网络，简称**AOE**。AOV网和AOE网都是有向无环图，区别在于AOE网中的边有权值；而AOV网中的边无权值。AOE网具有以下两个性质：

- 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始
- 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生

在AOE网中仅有一个入度为0的顶点，称为**开始顶点（源点）**，它表示整个工程的开始；网中也仅存在一个出度为0的顶点，称为**结束顶点（汇点）**，它表示整个工程的结束

只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的路径称为**关键路径**，而把关键路径上的活动称为**关键活动**。完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动话费的开销的总和，若关键路径不能按时完成，则整个工程的完成时间就会延长



下面是在寻找关键活动时所用到的几个参量的定义：

**事件v<sub>k</sub>的最早发生时间ve(k)**

它是指从源点v<sub>1</sub>到顶点v<sub>k</sub>的最长路径长度。事件v<sub>k</sub>的最早发生时间决定了所有从v<sub>k</sub>开始的活动能够开工的最早时间。可用下面的递推公式来计算：

ve(源点) = 0

ve(k) = Max{ve(j) + Weight(v<sub>j</sub>, v<sub>k</sub>)}，v<sub>k</sub>为v<sub>j</sub>的任意后继，Weight(v<sub>j</sub>, v<sub>k</sub>)表示<v<sub>j</sub>, v<sub>k</sub>>上的权值

计算ve()值时，按**从前往后**的顺序进行，可以在拓扑排序的基础上计算：

- ①初始时，令ve[1...n] = 0
- ②输出一个入度为0的顶点v<sub>j</sub>时，计算它所有直接后继顶点v<sub>k</sub>的最早发生时间，若ve[j] + Weight(v<sub>j</sub>, v<sub>k</sub>) > ve[k]，则ve[k] = ve[j] + Weight(v<sub>j</sub>, v<sub>k</sub>)。以此类推，直至输出全部顶点



**事件v<sub>k</sub>的最迟发生时间vl(k)**

它是指在不推迟整个工程完成的前提下，即保证它的后继事件v<sub>j</sub>在其最迟发生时间vl(j)能够发生时，该事件最迟必须发生的时间。可用下面的递推公式来计算：

vl(汇点) = ve(汇点)

vl(k) = Min{vl(j) - Weight(v<sub>k</sub>, v<sub>j</sub>)}，v<sub>k</sub>,为v<sub>j</sub>的任意前驱

注意：在计算vl(k)时，按**从后往前**的顺序进行，可以在逆拓扑排序的基础上计算

算vl(k)时，按从后往前的顺序进行，在上述拓扑排序中，增设一个栈以记录拓扑序列，拓扑排序结束后从栈顶至栈底便为逆拓扑有序序列。过程如下：

- ①初始时令vl[1...n] = ve[n]
- ②栈顶顶点v<sub>j</sub>出栈，计算其所有直接前驱顶点v<sub>k</sub>的最迟发生时间，若v[j] - Weight(v<sub>k</sub>, v<sub>j</sub>) < vl[k]，则vl[k] = v[j] - Weight(v<sub>k</sub>, v<sub>j</sub>)。以此类推，直至输出全部栈中顶点



**活动a<sub>i</sub>的最早开始时间e(i)**

它是指该活动弧的起点所表示的时间的最早发生时间。若边<v<sub>k</sub>, v<sub>j</sub>>表示活动a<sub>i</sub>，则有e(i) = ve(k)



**活动a<sub>i</sub>的最迟开始时间l(i)**

它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。若边<v<sub>k</sub>, v<sub>j</sub>>表示活动a<sub>i</sub>，则有l(i) = vl(j) - Weight(v<sub>k</sub>, v<sub>j</sub>)



**一个活动a<sub>i</sub>的最迟开始时间l(i)和其最早开始时间e(i)的差额d(i) = l(i) - e(i)**

它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动a<sub>i</sub>可以拖延的时间。若一个活动的时间余量为零，则说明该活动必须要如期完成，否则会拖延整个工程的进度，所以称l(i) - e(i) = 0即l(i) = e(i)的活动a<sub>i</sub>是关键活动

求关键路径的算法步骤如下：

- 从源点出发，令ve(源点) = 0，按拓扑有序求其余顶点的最早发生时间
- 从汇点出发，令vl(汇点) = ve(汇点)，按逆拓扑有序求其余顶点的最迟发生时间vl()
- 根据各顶点的ve()值求所有弧的最早开始时间e()
- 根据各顶点的vl()值求所有弧的最迟开始时间l()
- 求AOE网中所有活动的差额d() = l(i) - e(i)，找出所有d() = 0的活动构成关键路径



下面是求解关键路径的过程：

<img src="pictures\图\35.png"  />

- 求ve()：初始ve(1) = 0，在拓扑排序输出顶点过程中，求得ve(2) = 3, ve(3) = 2, ve(4) = max{ve(2) + 2, ve(3) + 4} = max{5, 6} = 6，ve(5) =6，ve(6) = max{ve(5) + 1, ve(4) + 2, ve(3) + 3} = max{7, 8, 5} = 8

如果这是一道选择题，根据上面所求ve()的过程就已经能知道关键路径（ve()值最大的一条路径）

- 求vl()：初始vl(6) = 8，在逆拓扑排序出栈过程中，求得vl(5) = 7，vl(4) = 6，vl(3) = min{vl(4) - 4, vl(6) - 3} = min{2, 5} = 2，vl(2) = min{vl(5) - 3, vl(4) - 2} = min{4, 4} = 4，vl(1)必然为0而无须再求
- 弧的最早开始时间e()等于该弧的起点的顶点的ve()
- 弧的最迟开始时间l(i)等于该弧的终点的顶点的vl()减去该弧持续的时间
- 根据l(i) - e(i) = 0的关键活动，得到额的关键路径为(v<sub>1</sub>, v<sub>3</sub>, v<sub>4</sub>, v<sub>6</sub>)



对于关键路径，需要注意以下几点：

- 关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此刻通过加快关键活动来缩短整个工程的工期。但一旦缩短到一定的程度，该关键活动就就可能会变长非关键活动
- 网中的关键路径并不唯一，且对于有几条关键路径的网，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的
